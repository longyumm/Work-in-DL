import torch
import torch.nn as nn
from torch.autograd import Variable
import torch.utils.data as Data
import torchvision 
import matplotlib.pyplot as plt

torch.manual_seed(1)

EPOCH=1
BATCH_SIZE=100
LR=0.01
DOWNLOAD_MINIST=True

train_data=torchvision.datasets.MNIST(root='./minist/',train=True,transform=torchvision.transforms.ToTensor(),download=DOWNLOAD_MINIST)
test_data=torchvision.datasets.MNIST(root='./minist/',train=False)

print(train_data.train_data.size())
print(train_data.train_labels.size())
plt.imshow(train_data.train_data[2].numpy(),cmap='gray')
#plt.show()

train_loader=Data.DataLoader(dataset=train_data,batch_size=BATCH_SIZE,shuffle=True)

test_x=Variable(torch.unsqueeze(test_data.test_data,dim=1),volatile=True).type(torch.FloatTensor)[:2000]/255.
test_y=test_data.test_labels[:2000]

##CNN_model

class CNN(nn.Module):
	def __init__(self):
		super(CNN,self).__init__()
		##input 1x28x28
		self.conv1=nn.Sequential(nn.Conv2d(in_channels=1,out_channels=16,kernel_size=5,stride=1,padding=2),nn.ReLU(),nn.MaxPool2d(kernel_size=2))
		##output 16x14x14 as the next input
		self.conv2=nn.Sequential(nn.Conv2d(16,32,5,1,2),nn.ReLU(),nn.MaxPool2d(2))
		##output 32x7x7
		self.out=nn.Linear(32*7*7,10)

	def forward(self,x):
		x=self.conv1(x)
		x=self.conv2(x)
		x=x.view(x.size(0),-1)
		output=self.out(x)
		return output,x

cnn = CNN()
print(cnn)

optimizer = torch.optim.Adam(cnn.parameters(),lr=LR)
loss_func=nn.CrossEntropyLoss()




for epoch in range(EPOCH):
	for step,(x,y)in enumerate(train_loader):
		b_x=Variable(x)
		b_y=Variable(y)

		output=cnn(b_x)[0]
		loss=loss_func(output,b_y)
		optimizer.zero_grad()
		loss.backward()
		optimizer.step()

		if step% 50 ==0:
			test_output,last_layer=cnn(test_x)
			pred_y=torch.max(test_output,1)[1].data.squeeze()
			accuracy=sum(pred_y==test_y)/float(test_y.size(0))
			print('Epoch:',epoch,'| train loss:%.4f'%loss.data[0],'| test acc:%.2f'%accuracy)

plt.ioff()

test_output,_=cnn(test_x[:20])
pred_y=torch.max(test_output,1)[1].data.numpy().squeeze()
print(pred_y,'prediction_number')
print(test_y[:20].numpy(),'real _number')



